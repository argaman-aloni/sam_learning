"""Module responsible for running the Fast Downward discrete planner."""

import logging
import os
import subprocess
import sys
import uuid
from pathlib import Path
from typing import Dict

from solvers.abstract_solver import AbstractSolver, SolutionOutputTypes

FAST_DOWNWARD_DIR_PATH = os.environ.get("FAST_DOWNWARD_DIR_PATH", "./fast-downward")
MAX_RUNNING_TIME = 60  # seconds


class FastDownwardSolver(AbstractSolver):
    """Class designated to use to activate the metric-FF solver on the cluster and parse its result."""

    logger: logging.Logger

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.name = "Fast Downward"

    @staticmethod
    def _remove_cost_from_file(solution_path: Path) -> None:
        """Removes the line that contains the plan cost from the plan file because the framework does not support it.

        :param solution_path: the path to the solution file.
        """
        with open(solution_path, "r") as solution_file:
            solution_lines = solution_file.readlines()

        with open(solution_path, "w") as solution_file:
            solution_file.writelines(solution_lines[:-1])

    @staticmethod
    def _remove_sas_file(sas_file_path: Path) -> None:
        """Removes the SAS file generated by the Fast Downward solver.

        :param sas_file_path: the path to the SAS file.
        """
        if sas_file_path.exists():
            sas_file_path.unlink(missing_ok=True)

    def solve_problem(
        self,
        domain_file_path: Path,
        problem_file_path: Path,
        problems_directory_path: Path,
        solving_timeout: int,
        tolerance: float = 0.1,
    ) -> SolutionOutputTypes:
        """Solves a single problem using the Fast Downward solver.

        :param domain_file_path: the path to the domain file.
        :param problem_file_path: the path to the problem file.
        :param problems_directory_path: the path to the directory containing the problems.
        :param solving_timeout: the timeout for the solving process.
        :param tolerance: unused parameter (added to create a uniform API).
        :return Whether the execution terminated successfully.
        """
        os.chdir(FAST_DOWNWARD_DIR_PATH)
        self.logger.debug(f"Starting to work on solving problem - {problem_file_path.stem}")
        solution_path = problems_directory_path / f"{problem_file_path.stem}.solution"
        sas_file_path = f"{domain_file_path.stem}_{uuid.uuid4()}_output.sas"
        running_options = [
            "--overall-time-limit",
            f"{solving_timeout}s",
            "--plan-file",
            str(solution_path.absolute()),
            "--sas-file",
            sas_file_path,
            str(domain_file_path.absolute()),
            str(problem_file_path.absolute()),
            "--evaluator",
            "'hcea=cea()'",
            "--search",
            "'lazy_greedy([hcea], preferred=[hcea])'",
        ]
        run_command = f"./fast-downward.py {' '.join(running_options)}"

        try:
            os.chdir(FAST_DOWNWARD_DIR_PATH)
            subprocess.check_output(run_command, shell=True)
            self.logger.info(f"Solver succeeded in solving problem - {problem_file_path.stem}")
            self._remove_cost_from_file(solution_path)
            self._remove_sas_file(Path(FAST_DOWNWARD_DIR_PATH) / sas_file_path)
            return SolutionOutputTypes.ok

        except subprocess.CalledProcessError as e:
            if e.returncode in [21, 23, 247]:
                self.logger.warning(
                    f"Fast Downward returned status code {e.returncode} - timeout on problem {problem_file_path.stem}."
                )
                return SolutionOutputTypes.timeout

            elif e.returncode in [11, 12]:
                self.logger.warning(
                    f"Fast Downward returned status code {e.returncode} - plan unsolvable for problem {problem_file_path.stem}."
                )
                return SolutionOutputTypes.no_solution

            self.logger.critical(f"Fast Downward returned status code {e.returncode} - unknown error.")
            return SolutionOutputTypes.solver_error

    def execute_solver(
        self,
        problems_directory_path: Path,
        domain_file_path: Path,
        problems_prefix: str = "pfile",
        tolerance: float = 0.01,
        solving_timeout: int = MAX_RUNNING_TIME,
    ) -> Dict[str, str]:
        """Runs the Fast Downward solver on all the problems in the given directory.

        :param problems_directory_path: the path to the directory containing the problems.
        :param domain_file_path: the path to the domain file.
        :param problems_prefix: the prefix of the problems files.
        :param tolerance: the tolerance of the solver (added to create a uniform API).
        :param solving_timeout: the timeout for the solving process.
        :return: a dictionary containing the solving status of each problem.
        """
        solving_stats = {}
        os.chdir(FAST_DOWNWARD_DIR_PATH)
        self.logger.info("Starting to solve the input problems using Fast-Downward solver.")
        for problem_file_path in problems_directory_path.glob(f"{problems_prefix}*.pddl"):
            self.logger.info(f"Fast Downward is starting to solve problem - {problem_file_path.stem}")
            termination_status = self.solve_problem(
                domain_file_path, problem_file_path, problems_directory_path, solving_timeout
            )
            num_retries = 0
            while termination_status == SolutionOutputTypes.solver_error and num_retries < 3:
                termination_status = self.solve_problem(
                    domain_file_path, problem_file_path, problems_directory_path, solving_timeout
                )
                num_retries += 1

            solving_stats[problem_file_path.stem] = termination_status.name

        return solving_stats


if __name__ == "__main__":
    args = sys.argv
    logging.basicConfig(
        format="%(asctime)s %(levelname)-8s %(message)s", datefmt="%Y-%m-%d %H:%M:%S", level=logging.DEBUG
    )
    solver = FastDownwardSolver()
    solver.solve_problem(
        domain_file_path=Path(args[1]),
        problem_file_path=Path(args[2]),
        problems_directory_path=Path(args[3]),
        solving_timeout=int(args[4]),
    )
