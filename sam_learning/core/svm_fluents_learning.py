"""Learns fluents using SVM."""
from typing import List, Tuple, Union

import numpy as np
import pandas as pd
from pddl_plus_parser.models import Domain, Observation
from sklearn.svm import LinearSVC

from sam_learning.core import LearnerDomain, ConditionType, prettify_coefficients, \
    prettify_floating_point_number
from sam_learning.core.unsafe_numeric_fluents_learning_base import UnsafeFluentsLearning, CLASS_COLUMN

TOLERANCE = 0.01
MAX_ALLOWED_ITERATIONS = 10


class SVMFluentsLearning(UnsafeFluentsLearning):
    """Learns models by using linear SVM classifier and evaluating the coefficients of the fluents."""

    def __init__(self, action_name: str, polynomial_degree: int = 0,
                 partial_domain: Union[Domain, LearnerDomain] = None):
        super().__init__(action_name, polynomial_degree, partial_domain)

    @staticmethod
    def calculate_expression_class(row_values: np.ndarray, coefficients: List[float], intercept: float) -> bool:
        """Indicate whether the row has been incorrectly classified.

        :param row_values: the row values to be classified.
        :param coefficients: the coefficients generated by the SVM model.
        :param intercept: the intercept generated by the SVM model.
        :return: whether the row has been incorrectly classified. (and thus should remain for the next iteration)
        """
        feature_values = row_values[:-1]
        class_column = row_values[-1]
        if class_column == 1:
            return sum(feature_values * coefficients) + intercept < 0  # positive class
        else:
            return sum(feature_values * coefficients) + intercept >= 0

    def _remove_rows_with_accurate_classification(
            self, input_df: pd.DataFrame, coefficients: List[float], intercept: float) -> pd.DataFrame:
        """

        :param input_df:
        :param coefficients:
        :param intercept:
        :return:
        """
        indicator_function = lambda row_values: self.calculate_expression_class(row_values, coefficients, intercept)
        return input_df[input_df.apply(indicator_function, axis=1)]

    def run_linear_svc(self, dataframe: pd.DataFrame) -> Tuple[List[float], float]:
        """Runs the linear SVC algorithm on the dataframe.

        :param dataframe: the input dataset.
        :return: the coefficients and the intercept of the SVC model.
        """
        self.logger.info("Running linear SVC model to learn the fluents coefficients and inequalities intercept...")
        svm_fluents_learning = LinearSVC(random_state=0, tol=1e-5)
        svm_fluents_learning.fit(dataframe.loc[:, dataframe.columns != CLASS_COLUMN], dataframe[CLASS_COLUMN])
        self.logger.debug("Model trained. Returning the coefficients and the intercept...")
        return svm_fluents_learning.coef_[0], svm_fluents_learning.intercept_[0]

    def learn_preconditions(self, positive_observations: List[Observation],
                            negative_observations: List[Observation]) -> Tuple[List[str], ConditionType]:
        """Learning the preconditions of an action using iterative execution of linear SVC on the data.

        Notice:
            Oblique tree uses SVM as the base for the calculation. For each SVC node it is defined that
            the goal is defined by sign(w*f(x) + b). The SVC node is defined by the function f(x)
            is the identity function.

        :return: the list of preconditions to be connected with an OR statement.
        """
        self.logger.info("Learning the preconditions of an action using iterative linear SVC technique.")
        dataframe = self._create_pre_state_classification_dataset(positive_observations, negative_observations)
        feature_names = list(dataframe.columns.values.tolist())
        coefficients_route = []
        intercept_route = []
        current_iteration = 0
        while current_iteration < MAX_ALLOWED_ITERATIONS and dataframe.shape[0] > 0:
            coefficients, intercept = self.run_linear_svc(dataframe)
            coefficients_route.append(prettify_coefficients(list(coefficients)))
            intercept_route.append(prettify_floating_point_number(intercept))
            dataframe = self._remove_rows_with_accurate_classification(dataframe, coefficients, intercept)
            current_iteration += 1

        return self._create_inequality_constraint_strings(feature_names, coefficients_route,
                                                          intercept_route), ConditionType.injunctive
